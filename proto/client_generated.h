// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLIENT_WSGW_PROTO_CLIENT_RECEIVE_ASYNC_EVENT_H_
#define FLATBUFFERS_GENERATED_CLIENT_WSGW_PROTO_CLIENT_RECEIVE_ASYNC_EVENT_H_

#include "flatbuffers/flatbuffers.h"

#include "shared_generated.h"

namespace WsGw {
namespace proto {
namespace Client {

struct Handshake;

struct HandshakeResponse;

namespace Send {

struct SendPacket;

struct GetServiceList;

struct WaitService;

struct CancelWaitService;

struct CallService;

struct CancelCallService;

struct SubscribeService;

struct UnscribeService;

}  // namespace Send

namespace Receive {

struct ReceivePacket;

namespace Sync {

struct SimpleResult;

struct ServiceDesc;

struct ServiceList;

struct ServiceStatus;

struct RequestResult;

struct SyncResult;

}  // namespace Sync

namespace Async {

struct AsyncResult;

struct WaitResult;

namespace Call {

struct CallResponse;

struct CallSuccess;

struct CallException;

}  // namespace Call

namespace Event {

struct EventPayload;

struct Event;

}  // namespace Event
}  // namespace Async
}  // namespace Receive

namespace Send {

enum Send {
  Send_NONE = 0,
  Send_GetServiceList = 1,
  Send_WaitService = 2,
  Send_CancelWaitService = 3,
  Send_CallService = 4,
  Send_CancelCallService = 5,
  Send_SubscribeService = 6,
  Send_UnscribeService = 7,
  Send_MIN = Send_NONE,
  Send_MAX = Send_UnscribeService
};

inline const Send (&EnumValuesSend())[8] {
  static const Send values[] = {
    Send_NONE,
    Send_GetServiceList,
    Send_WaitService,
    Send_CancelWaitService,
    Send_CallService,
    Send_CancelCallService,
    Send_SubscribeService,
    Send_UnscribeService
  };
  return values;
}

inline const char * const *EnumNamesSend() {
  static const char * const names[] = {
    "NONE",
    "GetServiceList",
    "WaitService",
    "CancelWaitService",
    "CallService",
    "CancelCallService",
    "SubscribeService",
    "UnscribeService",
    nullptr
  };
  return names;
}

inline const char *EnumNameSend(Send e) {
  if (e < Send_NONE || e > Send_UnscribeService) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSend()[index];
}

template<typename T> struct SendTraits {
  static const Send enum_value = Send_NONE;
};

template<> struct SendTraits<GetServiceList> {
  static const Send enum_value = Send_GetServiceList;
};

template<> struct SendTraits<WaitService> {
  static const Send enum_value = Send_WaitService;
};

template<> struct SendTraits<CancelWaitService> {
  static const Send enum_value = Send_CancelWaitService;
};

template<> struct SendTraits<CallService> {
  static const Send enum_value = Send_CallService;
};

template<> struct SendTraits<CancelCallService> {
  static const Send enum_value = Send_CancelCallService;
};

template<> struct SendTraits<SubscribeService> {
  static const Send enum_value = Send_SubscribeService;
};

template<> struct SendTraits<UnscribeService> {
  static const Send enum_value = Send_UnscribeService;
};

bool VerifySend(flatbuffers::Verifier &verifier, const void *obj, Send type);
bool VerifySendVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Send

namespace Receive {

enum Receive {
  Receive_NONE = 0,
  Receive_SyncResult = 1,
  Receive_AsyncResult = 2,
  Receive_MIN = Receive_NONE,
  Receive_MAX = Receive_AsyncResult
};

inline const Receive (&EnumValuesReceive())[3] {
  static const Receive values[] = {
    Receive_NONE,
    Receive_SyncResult,
    Receive_AsyncResult
  };
  return values;
}

inline const char * const *EnumNamesReceive() {
  static const char * const names[] = {
    "NONE",
    "SyncResult",
    "AsyncResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameReceive(Receive e) {
  if (e < Receive_NONE || e > Receive_AsyncResult) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReceive()[index];
}

template<typename T> struct ReceiveTraits {
  static const Receive enum_value = Receive_NONE;
};

template<> struct ReceiveTraits<WsGw::proto::Client::Receive::Sync::SyncResult> {
  static const Receive enum_value = Receive_SyncResult;
};

template<> struct ReceiveTraits<WsGw::proto::Client::Receive::Async::AsyncResult> {
  static const Receive enum_value = Receive_AsyncResult;
};

bool VerifyReceive(flatbuffers::Verifier &verifier, const void *obj, Receive type);
bool VerifyReceiveVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum OnlineStatus {
  OnlineStatus_Offline = 0,
  OnlineStatus_Online = 1,
  OnlineStatus_MIN = OnlineStatus_Offline,
  OnlineStatus_MAX = OnlineStatus_Online
};

inline const OnlineStatus (&EnumValuesOnlineStatus())[2] {
  static const OnlineStatus values[] = {
    OnlineStatus_Offline,
    OnlineStatus_Online
  };
  return values;
}

inline const char * const *EnumNamesOnlineStatus() {
  static const char * const names[] = {
    "Offline",
    "Online",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnlineStatus(OnlineStatus e) {
  if (e < OnlineStatus_Offline || e > OnlineStatus_Online) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOnlineStatus()[index];
}

namespace Sync {

enum Sync {
  Sync_NONE = 0,
  Sync_SimpleResult = 1,
  Sync_ServiceList = 2,
  Sync_ServiceStatus = 3,
  Sync_RequestResult = 4,
  Sync_MIN = Sync_NONE,
  Sync_MAX = Sync_RequestResult
};

inline const Sync (&EnumValuesSync())[5] {
  static const Sync values[] = {
    Sync_NONE,
    Sync_SimpleResult,
    Sync_ServiceList,
    Sync_ServiceStatus,
    Sync_RequestResult
  };
  return values;
}

inline const char * const *EnumNamesSync() {
  static const char * const names[] = {
    "NONE",
    "SimpleResult",
    "ServiceList",
    "ServiceStatus",
    "RequestResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameSync(Sync e) {
  if (e < Sync_NONE || e > Sync_RequestResult) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSync()[index];
}

template<typename T> struct SyncTraits {
  static const Sync enum_value = Sync_NONE;
};

template<> struct SyncTraits<SimpleResult> {
  static const Sync enum_value = Sync_SimpleResult;
};

template<> struct SyncTraits<ServiceList> {
  static const Sync enum_value = Sync_ServiceList;
};

template<> struct SyncTraits<ServiceStatus> {
  static const Sync enum_value = Sync_ServiceStatus;
};

template<> struct SyncTraits<RequestResult> {
  static const Sync enum_value = Sync_RequestResult;
};

bool VerifySync(flatbuffers::Verifier &verifier, const void *obj, Sync type);
bool VerifySyncVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Sync

namespace Async {

enum Async {
  Async_NONE = 0,
  Async_WaitResult = 1,
  Async_CallResponse = 2,
  Async_Event = 3,
  Async_MIN = Async_NONE,
  Async_MAX = Async_Event
};

inline const Async (&EnumValuesAsync())[4] {
  static const Async values[] = {
    Async_NONE,
    Async_WaitResult,
    Async_CallResponse,
    Async_Event
  };
  return values;
}

inline const char * const *EnumNamesAsync() {
  static const char * const names[] = {
    "NONE",
    "WaitResult",
    "CallResponse",
    "Event",
    nullptr
  };
  return names;
}

inline const char *EnumNameAsync(Async e) {
  if (e < Async_NONE || e > Async_Event) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAsync()[index];
}

template<typename T> struct AsyncTraits {
  static const Async enum_value = Async_NONE;
};

template<> struct AsyncTraits<WaitResult> {
  static const Async enum_value = Async_WaitResult;
};

template<> struct AsyncTraits<WsGw::proto::Client::Receive::Async::Call::CallResponse> {
  static const Async enum_value = Async_CallResponse;
};

template<> struct AsyncTraits<WsGw::proto::Client::Receive::Async::Event::Event> {
  static const Async enum_value = Async_Event;
};

bool VerifyAsync(flatbuffers::Verifier &verifier, const void *obj, Async type);
bool VerifyAsyncVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

namespace Call {

enum CallResponsePayload {
  CallResponsePayload_NONE = 0,
  CallResponsePayload_CallSuccess = 1,
  CallResponsePayload_CallException = 2,
  CallResponsePayload_MIN = CallResponsePayload_NONE,
  CallResponsePayload_MAX = CallResponsePayload_CallException
};

inline const CallResponsePayload (&EnumValuesCallResponsePayload())[3] {
  static const CallResponsePayload values[] = {
    CallResponsePayload_NONE,
    CallResponsePayload_CallSuccess,
    CallResponsePayload_CallException
  };
  return values;
}

inline const char * const *EnumNamesCallResponsePayload() {
  static const char * const names[] = {
    "NONE",
    "CallSuccess",
    "CallException",
    nullptr
  };
  return names;
}

inline const char *EnumNameCallResponsePayload(CallResponsePayload e) {
  if (e < CallResponsePayload_NONE || e > CallResponsePayload_CallException) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCallResponsePayload()[index];
}

template<typename T> struct CallResponsePayloadTraits {
  static const CallResponsePayload enum_value = CallResponsePayload_NONE;
};

template<> struct CallResponsePayloadTraits<CallSuccess> {
  static const CallResponsePayload enum_value = CallResponsePayload_CallSuccess;
};

template<> struct CallResponsePayloadTraits<CallException> {
  static const CallResponsePayload enum_value = CallResponsePayload_CallException;
};

bool VerifyCallResponsePayload(flatbuffers::Verifier &verifier, const void *obj, CallResponsePayload type);
bool VerifyCallResponsePayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Call
}  // namespace Async
}  // namespace Receive

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *magic() const {
    return GetPointer<const flatbuffers::String *>(VT_MAGIC);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAGIC) &&
           verifier.VerifyString(magic()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct HandshakeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(flatbuffers::Offset<flatbuffers::String> magic) {
    fbb_.AddOffset(Handshake::VT_MAGIC, magic);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Handshake::VT_VERSION, version, 0);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeBuilder &operator=(const HandshakeBuilder &);
  flatbuffers::Offset<Handshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> magic = 0,
    uint32_t version = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_magic(magic);
  return builder_.Finish();
}

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *magic = nullptr,
    uint32_t version = 0) {
  auto magic__ = magic ? _fbb.CreateString(magic) : 0;
  return WsGw::proto::Client::CreateHandshake(
      _fbb,
      magic__,
      version);
}

struct HandshakeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4
  };
  const flatbuffers::String *magic() const {
    return GetPointer<const flatbuffers::String *>(VT_MAGIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAGIC) &&
           verifier.VerifyString(magic()) &&
           verifier.EndTable();
  }
};

struct HandshakeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(flatbuffers::Offset<flatbuffers::String> magic) {
    fbb_.AddOffset(HandshakeResponse::VT_MAGIC, magic);
  }
  explicit HandshakeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeResponseBuilder &operator=(const HandshakeResponseBuilder &);
  flatbuffers::Offset<HandshakeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeResponse> CreateHandshakeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> magic = 0) {
  HandshakeResponseBuilder builder_(_fbb);
  builder_.add_magic(magic);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeResponse> CreateHandshakeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *magic = nullptr) {
  auto magic__ = magic ? _fbb.CreateString(magic) : 0;
  return WsGw::proto::Client::CreateHandshakeResponse(
      _fbb,
      magic__);
}

namespace Send {

struct SendPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEND_TYPE = 4,
    VT_SEND = 6
  };
  Send send_type() const {
    return static_cast<Send>(GetField<uint8_t>(VT_SEND_TYPE, 0));
  }
  const void *send() const {
    return GetPointer<const void *>(VT_SEND);
  }
  template<typename T> const T *send_as() const;
  const GetServiceList *send_as_GetServiceList() const {
    return send_type() == Send_GetServiceList ? static_cast<const GetServiceList *>(send()) : nullptr;
  }
  const WaitService *send_as_WaitService() const {
    return send_type() == Send_WaitService ? static_cast<const WaitService *>(send()) : nullptr;
  }
  const CancelWaitService *send_as_CancelWaitService() const {
    return send_type() == Send_CancelWaitService ? static_cast<const CancelWaitService *>(send()) : nullptr;
  }
  const CallService *send_as_CallService() const {
    return send_type() == Send_CallService ? static_cast<const CallService *>(send()) : nullptr;
  }
  const CancelCallService *send_as_CancelCallService() const {
    return send_type() == Send_CancelCallService ? static_cast<const CancelCallService *>(send()) : nullptr;
  }
  const SubscribeService *send_as_SubscribeService() const {
    return send_type() == Send_SubscribeService ? static_cast<const SubscribeService *>(send()) : nullptr;
  }
  const UnscribeService *send_as_UnscribeService() const {
    return send_type() == Send_UnscribeService ? static_cast<const UnscribeService *>(send()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEND_TYPE) &&
           VerifyOffset(verifier, VT_SEND) &&
           VerifySend(verifier, send(), send_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GetServiceList *SendPacket::send_as<GetServiceList>() const {
  return send_as_GetServiceList();
}

template<> inline const WaitService *SendPacket::send_as<WaitService>() const {
  return send_as_WaitService();
}

template<> inline const CancelWaitService *SendPacket::send_as<CancelWaitService>() const {
  return send_as_CancelWaitService();
}

template<> inline const CallService *SendPacket::send_as<CallService>() const {
  return send_as_CallService();
}

template<> inline const CancelCallService *SendPacket::send_as<CancelCallService>() const {
  return send_as_CancelCallService();
}

template<> inline const SubscribeService *SendPacket::send_as<SubscribeService>() const {
  return send_as_SubscribeService();
}

template<> inline const UnscribeService *SendPacket::send_as<UnscribeService>() const {
  return send_as_UnscribeService();
}

struct SendPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_send_type(Send send_type) {
    fbb_.AddElement<uint8_t>(SendPacket::VT_SEND_TYPE, static_cast<uint8_t>(send_type), 0);
  }
  void add_send(flatbuffers::Offset<void> send) {
    fbb_.AddOffset(SendPacket::VT_SEND, send);
  }
  explicit SendPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SendPacketBuilder &operator=(const SendPacketBuilder &);
  flatbuffers::Offset<SendPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SendPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<SendPacket> CreateSendPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Send send_type = Send_NONE,
    flatbuffers::Offset<void> send = 0) {
  SendPacketBuilder builder_(_fbb);
  builder_.add_send(send);
  builder_.add_send_type(send_type);
  return builder_.Finish();
}

struct GetServiceList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetServiceListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetServiceListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetServiceListBuilder &operator=(const GetServiceListBuilder &);
  flatbuffers::Offset<GetServiceList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetServiceList>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetServiceList> CreateGetServiceList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetServiceListBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WaitService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct WaitServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(WaitService::VT_NAME, name);
  }
  explicit WaitServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaitServiceBuilder &operator=(const WaitServiceBuilder &);
  flatbuffers::Offset<WaitService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WaitService>(end);
    return o;
  }
};

inline flatbuffers::Offset<WaitService> CreateWaitService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  WaitServiceBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<WaitService> CreateWaitServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return WsGw::proto::Client::Send::CreateWaitService(
      _fbb,
      name__);
}

struct CancelWaitService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CancelWaitServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CancelWaitService::VT_NAME, name);
  }
  explicit CancelWaitServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelWaitServiceBuilder &operator=(const CancelWaitServiceBuilder &);
  flatbuffers::Offset<CancelWaitService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelWaitService>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelWaitService> CreateCancelWaitService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CancelWaitServiceBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelWaitService> CreateCancelWaitServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return WsGw::proto::Client::Send::CreateCancelWaitService(
      _fbb,
      name__);
}

struct CallService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_KEY = 6,
    VT_PAYLOAD = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct CallServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CallService::VT_NAME, name);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(CallService::VT_KEY, key);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(CallService::VT_PAYLOAD, payload);
  }
  explicit CallServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallServiceBuilder &operator=(const CallServiceBuilder &);
  flatbuffers::Offset<CallService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallService>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallService> CreateCallService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  CallServiceBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_key(key);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallService> CreateCallServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *key = nullptr,
    const std::vector<uint8_t> *payload = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return WsGw::proto::Client::Send::CreateCallService(
      _fbb,
      name__,
      key__,
      payload__);
}

struct CancelCallService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ID = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct CancelCallServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CancelCallService::VT_NAME, name);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(CancelCallService::VT_ID, id, 0);
  }
  explicit CancelCallServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelCallServiceBuilder &operator=(const CancelCallServiceBuilder &);
  flatbuffers::Offset<CancelCallService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelCallService>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelCallService> CreateCancelCallService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t id = 0) {
  CancelCallServiceBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelCallService> CreateCancelCallServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return WsGw::proto::Client::Send::CreateCancelCallService(
      _fbb,
      name__,
      id);
}

struct SubscribeService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_KEY = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct SubscribeServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubscribeService::VT_NAME, name);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(SubscribeService::VT_KEY, key);
  }
  explicit SubscribeServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubscribeServiceBuilder &operator=(const SubscribeServiceBuilder &);
  flatbuffers::Offset<SubscribeService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeService>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeService> CreateSubscribeService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  SubscribeServiceBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubscribeService> CreateSubscribeServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *key = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return WsGw::proto::Client::Send::CreateSubscribeService(
      _fbb,
      name__,
      key__);
}

struct UnscribeService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_KEY = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct UnscribeServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UnscribeService::VT_NAME, name);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(UnscribeService::VT_KEY, key);
  }
  explicit UnscribeServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnscribeServiceBuilder &operator=(const UnscribeServiceBuilder &);
  flatbuffers::Offset<UnscribeService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnscribeService>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnscribeService> CreateUnscribeService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  UnscribeServiceBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnscribeService> CreateUnscribeServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *key = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return WsGw::proto::Client::Send::CreateUnscribeService(
      _fbb,
      name__,
      key__);
}

}  // namespace Send

namespace Receive {

struct ReceivePacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECEIVE_TYPE = 4,
    VT_RECEIVE = 6
  };
  Receive receive_type() const {
    return static_cast<Receive>(GetField<uint8_t>(VT_RECEIVE_TYPE, 0));
  }
  const void *receive() const {
    return GetPointer<const void *>(VT_RECEIVE);
  }
  template<typename T> const T *receive_as() const;
  const WsGw::proto::Client::Receive::Sync::SyncResult *receive_as_SyncResult() const {
    return receive_type() == Receive_SyncResult ? static_cast<const WsGw::proto::Client::Receive::Sync::SyncResult *>(receive()) : nullptr;
  }
  const WsGw::proto::Client::Receive::Async::AsyncResult *receive_as_AsyncResult() const {
    return receive_type() == Receive_AsyncResult ? static_cast<const WsGw::proto::Client::Receive::Async::AsyncResult *>(receive()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RECEIVE_TYPE) &&
           VerifyOffset(verifier, VT_RECEIVE) &&
           VerifyReceive(verifier, receive(), receive_type()) &&
           verifier.EndTable();
  }
};

template<> inline const WsGw::proto::Client::Receive::Sync::SyncResult *ReceivePacket::receive_as<WsGw::proto::Client::Receive::Sync::SyncResult>() const {
  return receive_as_SyncResult();
}

template<> inline const WsGw::proto::Client::Receive::Async::AsyncResult *ReceivePacket::receive_as<WsGw::proto::Client::Receive::Async::AsyncResult>() const {
  return receive_as_AsyncResult();
}

struct ReceivePacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receive_type(Receive receive_type) {
    fbb_.AddElement<uint8_t>(ReceivePacket::VT_RECEIVE_TYPE, static_cast<uint8_t>(receive_type), 0);
  }
  void add_receive(flatbuffers::Offset<void> receive) {
    fbb_.AddOffset(ReceivePacket::VT_RECEIVE, receive);
  }
  explicit ReceivePacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReceivePacketBuilder &operator=(const ReceivePacketBuilder &);
  flatbuffers::Offset<ReceivePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReceivePacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReceivePacket> CreateReceivePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Receive receive_type = Receive_NONE,
    flatbuffers::Offset<void> receive = 0) {
  ReceivePacketBuilder builder_(_fbb);
  builder_.add_receive(receive);
  builder_.add_receive_type(receive_type);
  return builder_.Finish();
}

namespace Sync {

struct SimpleResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OK = 4
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK) &&
           verifier.EndTable();
  }
};

struct SimpleResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(SimpleResult::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit SimpleResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimpleResultBuilder &operator=(const SimpleResultBuilder &);
  flatbuffers::Offset<SimpleResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimpleResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimpleResult> CreateSimpleResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = false) {
  SimpleResultBuilder builder_(_fbb);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct ServiceDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_VERSION = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
};

struct ServiceDescBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ServiceDesc::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ServiceDesc::VT_TYPE, type);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ServiceDesc::VT_VERSION, version);
  }
  explicit ServiceDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceDescBuilder &operator=(const ServiceDescBuilder &);
  flatbuffers::Offset<ServiceDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServiceDesc> CreateServiceDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ServiceDescBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_type(type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServiceDesc> CreateServiceDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *type = nullptr,
    const char *version = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return WsGw::proto::Client::Receive::Sync::CreateServiceDesc(
      _fbb,
      name__,
      type__,
      version__);
}

struct ServiceList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ServiceDesc>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ServiceDesc>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct ServiceListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceDesc>>> list) {
    fbb_.AddOffset(ServiceList::VT_LIST, list);
  }
  explicit ServiceListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceListBuilder &operator=(const ServiceListBuilder &);
  flatbuffers::Offset<ServiceList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServiceList> CreateServiceList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceDesc>>> list = 0) {
  ServiceListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServiceList> CreateServiceListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ServiceDesc>> *list = nullptr) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<ServiceDesc>>(*list) : 0;
  return WsGw::proto::Client::Receive::Sync::CreateServiceList(
      _fbb,
      list__);
}

struct ServiceStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  WsGw::proto::Client::Receive::OnlineStatus status() const {
    return static_cast<WsGw::proto::Client::Receive::OnlineStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct ServiceStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(WsGw::proto::Client::Receive::OnlineStatus status) {
    fbb_.AddElement<uint8_t>(ServiceStatus::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit ServiceStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceStatusBuilder &operator=(const ServiceStatusBuilder &);
  flatbuffers::Offset<ServiceStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServiceStatus> CreateServiceStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    WsGw::proto::Client::Receive::OnlineStatus status = WsGw::proto::Client::Receive::OnlineStatus_Offline) {
  ServiceStatusBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct RequestResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RequestResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(RequestResult::VT_ID, id, 0);
  }
  explicit RequestResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestResultBuilder &operator=(const RequestResultBuilder &);
  flatbuffers::Offset<RequestResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestResult> CreateRequestResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  RequestResultBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SyncResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYNC_TYPE = 4,
    VT_SYNC = 6
  };
  Sync sync_type() const {
    return static_cast<Sync>(GetField<uint8_t>(VT_SYNC_TYPE, 0));
  }
  const void *sync() const {
    return GetPointer<const void *>(VT_SYNC);
  }
  template<typename T> const T *sync_as() const;
  const SimpleResult *sync_as_SimpleResult() const {
    return sync_type() == Sync_SimpleResult ? static_cast<const SimpleResult *>(sync()) : nullptr;
  }
  const ServiceList *sync_as_ServiceList() const {
    return sync_type() == Sync_ServiceList ? static_cast<const ServiceList *>(sync()) : nullptr;
  }
  const ServiceStatus *sync_as_ServiceStatus() const {
    return sync_type() == Sync_ServiceStatus ? static_cast<const ServiceStatus *>(sync()) : nullptr;
  }
  const RequestResult *sync_as_RequestResult() const {
    return sync_type() == Sync_RequestResult ? static_cast<const RequestResult *>(sync()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SYNC_TYPE) &&
           VerifyOffset(verifier, VT_SYNC) &&
           VerifySync(verifier, sync(), sync_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SimpleResult *SyncResult::sync_as<SimpleResult>() const {
  return sync_as_SimpleResult();
}

template<> inline const ServiceList *SyncResult::sync_as<ServiceList>() const {
  return sync_as_ServiceList();
}

template<> inline const ServiceStatus *SyncResult::sync_as<ServiceStatus>() const {
  return sync_as_ServiceStatus();
}

template<> inline const RequestResult *SyncResult::sync_as<RequestResult>() const {
  return sync_as_RequestResult();
}

struct SyncResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sync_type(Sync sync_type) {
    fbb_.AddElement<uint8_t>(SyncResult::VT_SYNC_TYPE, static_cast<uint8_t>(sync_type), 0);
  }
  void add_sync(flatbuffers::Offset<void> sync) {
    fbb_.AddOffset(SyncResult::VT_SYNC, sync);
  }
  explicit SyncResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SyncResultBuilder &operator=(const SyncResultBuilder &);
  flatbuffers::Offset<SyncResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SyncResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<SyncResult> CreateSyncResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    Sync sync_type = Sync_NONE,
    flatbuffers::Offset<void> sync = 0) {
  SyncResultBuilder builder_(_fbb);
  builder_.add_sync(sync);
  builder_.add_sync_type(sync_type);
  return builder_.Finish();
}

}  // namespace Sync

namespace Async {

struct AsyncResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASYNC_TYPE = 4,
    VT_ASYNC = 6
  };
  Async async_type() const {
    return static_cast<Async>(GetField<uint8_t>(VT_ASYNC_TYPE, 0));
  }
  const void *async() const {
    return GetPointer<const void *>(VT_ASYNC);
  }
  template<typename T> const T *async_as() const;
  const WaitResult *async_as_WaitResult() const {
    return async_type() == Async_WaitResult ? static_cast<const WaitResult *>(async()) : nullptr;
  }
  const WsGw::proto::Client::Receive::Async::Call::CallResponse *async_as_CallResponse() const {
    return async_type() == Async_CallResponse ? static_cast<const WsGw::proto::Client::Receive::Async::Call::CallResponse *>(async()) : nullptr;
  }
  const WsGw::proto::Client::Receive::Async::Event::Event *async_as_Event() const {
    return async_type() == Async_Event ? static_cast<const WsGw::proto::Client::Receive::Async::Event::Event *>(async()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ASYNC_TYPE) &&
           VerifyOffset(verifier, VT_ASYNC) &&
           VerifyAsync(verifier, async(), async_type()) &&
           verifier.EndTable();
  }
};

template<> inline const WaitResult *AsyncResult::async_as<WaitResult>() const {
  return async_as_WaitResult();
}

template<> inline const WsGw::proto::Client::Receive::Async::Call::CallResponse *AsyncResult::async_as<WsGw::proto::Client::Receive::Async::Call::CallResponse>() const {
  return async_as_CallResponse();
}

template<> inline const WsGw::proto::Client::Receive::Async::Event::Event *AsyncResult::async_as<WsGw::proto::Client::Receive::Async::Event::Event>() const {
  return async_as_Event();
}

struct AsyncResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_async_type(Async async_type) {
    fbb_.AddElement<uint8_t>(AsyncResult::VT_ASYNC_TYPE, static_cast<uint8_t>(async_type), 0);
  }
  void add_async(flatbuffers::Offset<void> async) {
    fbb_.AddOffset(AsyncResult::VT_ASYNC, async);
  }
  explicit AsyncResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AsyncResultBuilder &operator=(const AsyncResultBuilder &);
  flatbuffers::Offset<AsyncResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AsyncResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<AsyncResult> CreateAsyncResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    Async async_type = Async_NONE,
    flatbuffers::Offset<void> async = 0) {
  AsyncResultBuilder builder_(_fbb);
  builder_.add_async(async);
  builder_.add_async_type(async_type);
  return builder_.Finish();
}

struct WaitResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STATUS = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  WsGw::proto::Client::Receive::OnlineStatus status() const {
    return static_cast<WsGw::proto::Client::Receive::OnlineStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct WaitResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(WaitResult::VT_NAME, name);
  }
  void add_status(WsGw::proto::Client::Receive::OnlineStatus status) {
    fbb_.AddElement<uint8_t>(WaitResult::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit WaitResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaitResultBuilder &operator=(const WaitResultBuilder &);
  flatbuffers::Offset<WaitResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WaitResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<WaitResult> CreateWaitResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    WsGw::proto::Client::Receive::OnlineStatus status = WsGw::proto::Client::Receive::OnlineStatus_Offline) {
  WaitResultBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<WaitResult> CreateWaitResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    WsGw::proto::Client::Receive::OnlineStatus status = WsGw::proto::Client::Receive::OnlineStatus_Offline) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return WsGw::proto::Client::Receive::Async::CreateWaitResult(
      _fbb,
      name__,
      status);
}

namespace Call {

struct CallResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ID = 6,
    VT_PAYLOAD_TYPE = 8,
    VT_PAYLOAD = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  CallResponsePayload payload_type() const {
    return static_cast<CallResponsePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const CallSuccess *payload_as_CallSuccess() const {
    return payload_type() == CallResponsePayload_CallSuccess ? static_cast<const CallSuccess *>(payload()) : nullptr;
  }
  const CallException *payload_as_CallException() const {
    return payload_type() == CallResponsePayload_CallException ? static_cast<const CallException *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyCallResponsePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CallSuccess *CallResponse::payload_as<CallSuccess>() const {
  return payload_as_CallSuccess();
}

template<> inline const CallException *CallResponse::payload_as<CallException>() const {
  return payload_as_CallException();
}

struct CallResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CallResponse::VT_NAME, name);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(CallResponse::VT_ID, id, 0);
  }
  void add_payload_type(CallResponsePayload payload_type) {
    fbb_.AddElement<uint8_t>(CallResponse::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(CallResponse::VT_PAYLOAD, payload);
  }
  explicit CallResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallResponseBuilder &operator=(const CallResponseBuilder &);
  flatbuffers::Offset<CallResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallResponse> CreateCallResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t id = 0,
    CallResponsePayload payload_type = CallResponsePayload_NONE,
    flatbuffers::Offset<void> payload = 0) {
  CallResponseBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallResponse> CreateCallResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t id = 0,
    CallResponsePayload payload_type = CallResponsePayload_NONE,
    flatbuffers::Offset<void> payload = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return WsGw::proto::Client::Receive::Async::Call::CreateCallResponse(
      _fbb,
      name__,
      id,
      payload_type,
      payload);
}

struct CallSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD = 4
  };
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct CallSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(CallSuccess::VT_PAYLOAD, payload);
  }
  explicit CallSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallSuccessBuilder &operator=(const CallSuccessBuilder &);
  flatbuffers::Offset<CallSuccess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallSuccess> CreateCallSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  CallSuccessBuilder builder_(_fbb);
  builder_.add_payload(payload);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallSuccess> CreateCallSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return WsGw::proto::Client::Receive::Async::Call::CreateCallSuccess(
      _fbb,
      payload__);
}

struct CallException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4
  };
  const WsGw::proto::ExceptionInfo *info() const {
    return GetPointer<const WsGw::proto::ExceptionInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
};

struct CallExceptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<WsGw::proto::ExceptionInfo> info) {
    fbb_.AddOffset(CallException::VT_INFO, info);
  }
  explicit CallExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallExceptionBuilder &operator=(const CallExceptionBuilder &);
  flatbuffers::Offset<CallException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallException>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallException> CreateCallException(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<WsGw::proto::ExceptionInfo> info = 0) {
  CallExceptionBuilder builder_(_fbb);
  builder_.add_info(info);
  return builder_.Finish();
}

}  // namespace Call

namespace Event {

struct EventPayload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD = 4
  };
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct EventPayloadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(EventPayload::VT_PAYLOAD, payload);
  }
  explicit EventPayloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventPayloadBuilder &operator=(const EventPayloadBuilder &);
  flatbuffers::Offset<EventPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventPayload>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventPayload> CreateEventPayload(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  EventPayloadBuilder builder_(_fbb);
  builder_.add_payload(payload);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventPayload> CreateEventPayloadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return WsGw::proto::Client::Receive::Async::Event::CreateEventPayload(
      _fbb,
      payload__);
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_KEY = 6,
    VT_PAYLOAD = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const EventPayload *payload() const {
    return GetPointer<const EventPayload *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyTable(payload()) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Event::VT_NAME, name);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Event::VT_KEY, key);
  }
  void add_payload(flatbuffers::Offset<EventPayload> payload) {
    fbb_.AddOffset(Event::VT_PAYLOAD, payload);
  }
  explicit EventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventBuilder &operator=(const EventBuilder &);
  flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<EventPayload> payload = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_key(key);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Event> CreateEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *key = nullptr,
    flatbuffers::Offset<EventPayload> payload = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return WsGw::proto::Client::Receive::Async::Event::CreateEvent(
      _fbb,
      name__,
      key__,
      payload);
}

}  // namespace Event
}  // namespace Async
}  // namespace Receive

namespace Send {

}  // namespace Send

namespace Receive {

namespace Sync {

}  // namespace Sync

namespace Async {

namespace Call {

}  // namespace Call

namespace Event {

}  // namespace Event
}  // namespace Async
}  // namespace Receive

namespace Send {

inline bool VerifySend(flatbuffers::Verifier &verifier, const void *obj, Send type) {
  switch (type) {
    case Send_NONE: {
      return true;
    }
    case Send_GetServiceList: {
      auto ptr = reinterpret_cast<const GetServiceList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_WaitService: {
      auto ptr = reinterpret_cast<const WaitService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_CancelWaitService: {
      auto ptr = reinterpret_cast<const CancelWaitService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_CallService: {
      auto ptr = reinterpret_cast<const CallService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_CancelCallService: {
      auto ptr = reinterpret_cast<const CancelCallService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_SubscribeService: {
      auto ptr = reinterpret_cast<const SubscribeService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Send_UnscribeService: {
      auto ptr = reinterpret_cast<const UnscribeService *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySendVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySend(
        verifier,  values->Get(i), types->GetEnum<Send>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Send

namespace Receive {

inline bool VerifyReceive(flatbuffers::Verifier &verifier, const void *obj, Receive type) {
  switch (type) {
    case Receive_NONE: {
      return true;
    }
    case Receive_SyncResult: {
      auto ptr = reinterpret_cast<const WsGw::proto::Client::Receive::Sync::SyncResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Receive_AsyncResult: {
      auto ptr = reinterpret_cast<const WsGw::proto::Client::Receive::Async::AsyncResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyReceiveVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReceive(
        verifier,  values->Get(i), types->GetEnum<Receive>(i))) {
      return false;
    }
  }
  return true;
}

namespace Sync {

inline bool VerifySync(flatbuffers::Verifier &verifier, const void *obj, Sync type) {
  switch (type) {
    case Sync_NONE: {
      return true;
    }
    case Sync_SimpleResult: {
      auto ptr = reinterpret_cast<const SimpleResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Sync_ServiceList: {
      auto ptr = reinterpret_cast<const ServiceList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Sync_ServiceStatus: {
      auto ptr = reinterpret_cast<const ServiceStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Sync_RequestResult: {
      auto ptr = reinterpret_cast<const RequestResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySyncVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySync(
        verifier,  values->Get(i), types->GetEnum<Sync>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Sync

namespace Async {

inline bool VerifyAsync(flatbuffers::Verifier &verifier, const void *obj, Async type) {
  switch (type) {
    case Async_NONE: {
      return true;
    }
    case Async_WaitResult: {
      auto ptr = reinterpret_cast<const WaitResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Async_CallResponse: {
      auto ptr = reinterpret_cast<const WsGw::proto::Client::Receive::Async::Call::CallResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Async_Event: {
      auto ptr = reinterpret_cast<const WsGw::proto::Client::Receive::Async::Event::Event *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAsyncVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAsync(
        verifier,  values->Get(i), types->GetEnum<Async>(i))) {
      return false;
    }
  }
  return true;
}

namespace Call {

inline bool VerifyCallResponsePayload(flatbuffers::Verifier &verifier, const void *obj, CallResponsePayload type) {
  switch (type) {
    case CallResponsePayload_NONE: {
      return true;
    }
    case CallResponsePayload_CallSuccess: {
      auto ptr = reinterpret_cast<const CallSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CallResponsePayload_CallException: {
      auto ptr = reinterpret_cast<const CallException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCallResponsePayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCallResponsePayload(
        verifier,  values->Get(i), types->GetEnum<CallResponsePayload>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Call
}  // namespace Async
}  // namespace Receive
}  // namespace Client
}  // namespace proto
}  // namespace WsGw

#endif  // FLATBUFFERS_GENERATED_CLIENT_WSGW_PROTO_CLIENT_RECEIVE_ASYNC_EVENT_H_
